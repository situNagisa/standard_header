import os
import sys

cpp_headers = [
    # c header
    "cassert",
    "cctype",
    "cerrno",
    "cfenv",
    "cfloat",
    "cinttypes",
    "climits",
    "clocale",
    "cmath",
    "csetjmp",
    "csignal",
    "cstdarg",
    "cstddef",
    "cstdint",
    "cstdio",
    "cstdlib",
    "cstring",
    "ctime",
    "cuchar",
    "cwchar",
    "cwctype",

    # cpp header
    "algorithm",
    "bitset",
    "complex",
    "deque",
    "exception",
    "fstream",
    "functional",
    "iomanip",
    "iostream",
    "ios",
    "iosfwd",
    "iostream",
    "istream",
    "iterator",
    "limits",
    "list",
    "locale",
    "map",
    "memory",
    "new",
    "numeric",
    "ostream",
    "queue",
    "set",
    "sstream",
    "stack",
    "stdexcept",
    "streambuf",
    "string",
    "typeinfo",
    "utility",
    "valarray",
    "vector",

    # cpp 11 header
    "array",
    "atomic",
    "chrono",
    "codecvt",
    "condition_variable",
    "forward_list",
    "future",
    "initializer_list",
    "mutex",
    "random",
    "ratio",
    "regex",
    "scoped_allocator",
    "system_error",
    "thread",
    "tuple",
    "type_traits",
    "typeindex",
    "unordered_map",
    "unordered_set",

    # cpp 14 header
    "shared_mutex",

    # cpp 17 header
    "any",
    "charconv",
    "execution",
    "filesystem",
    "memory_resource",
    "optional",
    "string_view",
    "variant",

    # cpp 20 header
    "barrier",
    "bit",
    "compare",
    "concepts",
    "coroutine",
    "format",
    "latch",
    "numbers",
    "ranges",
    "semaphore",
    "source_location",
    "span",
    "stop_token",
    "syncstream",
    "version",

    # cpp 23 header
    "expected",
    "flat_map",
    "flat_set",
    "generator",
    "mdspan",
    "print",
    "spanstream",
    "stacktrace",
    "stdfloat",

    # cpp 26 header
    "debugging",
    "hazard_pointer",
    "inplace_vector",
    "linalg",
    "rcu",
    "text_encoding",
]

maybe_freestanding_headers = [
    "cstddef",
    "cstdlib",
    "cfloat",
    "climits",
    "limits",
    "version",
    "cstdint",
    "new",
    "typeinfo",
    "source_location",
    "exception",
    "initializer_list",
    "compare",
    "coroutine",
    "cstdarg",
    "debugging",
    "concepts",
    "cerrno",
    "system_error",
    "memory",
    "type_traits",
    "ratio",
    "utility",
    "tuple",
    "functional",
    "charconv",
    "bit",
    "string",
    "cstring",
    "cwchar",
    "iterator",
    "ranges",
    "cmath",
    "atomic",

    "algorithm",
    "array",
    "mdspan",
    "memory",
    "numeric",
    "optional",
    "string_view",
    "tuple",
    "variant",
]

def define(macro, value, tab_count = 0):
    return f"#" + (tab_count * '\t') + f" {macro} {value}\n"

def generate_macro_optional(output_file):
    with open(output_file, 'w') as f:
        f.write("#pragma once\n\n")
        f.write("// this file is generated by standard_header.py\n\n")
        for header in cpp_headers:
            f.write(f'#if NGS_STANDARD_HEADER_INCLUDE_{header.upper()}\n')
            f.write(f'#\tinclude <{header}>\n')
            f.write('#endif\n')
            f.write('\n')

def generate_auto_config(output_file):
    with open(output_file, 'w') as f:
        f.write("#pragma once\n\n")
        f.write("// this file is generated by standard_header.py\n\n")
        f.write("#include \"./auto_config_freestanding.h\"\n\n")
        for header in cpp_headers:
            f.write(f"#ifndef NGS_STANDARD_HEADER_INCLUDE_{header.upper()}\n")
            if header in maybe_freestanding_headers:
                f.write(f"#\tdefine NGS_STANDARD_HEADER_INCLUDE_{header.upper()} NGS_STANDARD_HEADER_FREESTANDING_{header.upper()}\n")
            else:
                f.write(f"#\tdefine NGS_STANDARD_HEADER_INCLUDE_{header.upper()} __has_include(<{header}>)\n")
            f.write("#endif\n")
            f.write(f"\n")

def generate_only_freestanding(output_file):
    with open(output_file, 'w') as f:
        f.write("#pragma once\n\n")
        f.write("// this file is generated by standard_header.py\n\n")
        for header in cpp_headers:
            macro = f"NGS_STANDARD_HEADER_INCLUDE_{header.upper()}"

            if header not in maybe_freestanding_headers:
                f.write(f"#undef {macro}\n")
                f.write(f"#define {macro} 0\n")
            else:
                f.write(f"#if !({macro})\n")
                f.write(f"#\tundef {macro}\n")
                f.write(f"#\tdefine {macro} 0\n")
                f.write(f"#endif\n")
            f.write("\n")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python gen_standard_header.py <function> <output_file>")
        print("Example: python gen_standard_header.py generate_macro_optional path/to/file.h")
        print("Supported functions: ")
        print("\tgenerate_macro_optional")
        print("\tgenerate_auto_config")
        print("\tgenerate_only_freestanding")
        sys.exit(1)
    output_file = sys.argv[2]
    globals()[sys.argv[1]](output_file)
    print(f"{sys.argv[1]} standard header in {output_file}")
